\documentclass[compress]{beamer}

\mode<presentation>
{
  \usetheme{Warsaw}
  % or ...
	\useoutertheme{infolines}
  \setbeamercovered{transparent}
  % or whatever (possibly just delete it)
}

\usepackage{verbatim}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows}
\usetikzlibrary{shapes}
\tikzstyle{block}=[draw opacity=0.7,line width=1.4cm]

\lstloadlanguages{C++}
\lstnewenvironment{code}
	{%\lstset{	numbers=none, frame=lines, basicstyle=\small\ttfamily, }%
	 \csname lst@SetFirstLabel\endcsname}
	{\csname lst@SaveFirstLabel\endcsname}
\lstset{% general command to set parameter(s)
	language=C++, basicstyle=\footnotesize\sffamily, keywordstyle=\slshape,
	emph=[1]{tipo,usa}, emphstyle={[1]\sffamily\bfseries},
	basewidth={0.47em,0.40em},
	columns=fixed, fontadjust, resetmargins, xrightmargin=5pt, xleftmargin=15pt,
	flexiblecolumns=false, tabsize=2, breaklines,	breakatwhitespace=false, extendedchars=true,
	numbers=left, numberstyle=\tiny, stepnumber=1, numbersep=9pt,
	frame=l, framesep=3pt,
}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% or whatever
\usepackage{fancyvrb}
\usepackage{times}
% Or whatever. Note that the encoding and the font should match. If T1
% does not look nice, try deleting the line with the fontenc.


\title[Búsqueda Binaria] % (optional, use only with long paper titles)
{Búsqueda Binaria}

\author[Quimey Vivas] % (optional, use only with lots of authors)
{Quimey Vivas \\ Leopoldo Taravilse}
% - Give the names in the same order as the appear in the paper.
% - Use the \inst{?} command only if the authors have different
%   affiliation.
\institute[Avature] % (optional, but mostly needed)
{
  Avature Argentina
}
\date[TC 2018] % (optional, should be abbreviation of conference name)
{Training Camp 2018}

% Acá se puede insertar el logo de la UBA
% \pgfdeclareimage[height=0.5cm]{university-logo}{university-logo-filename}
% \logo{\pgfuseimage{university-logo}}



% Delete this, if you do not want the table of contents to pop up at
% the beginning of each subsection:
\AtBeginSubsection[]
{
  \begin{frame}<beamer>{Contenidos}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}


% If you wish to uncover everything in a step-wise fashion, uncomment
% the following command:

%\beamerdefaultoverlayspecification{<+->}
\fvset{fontsize=\scriptsize,numbersep=1mm,commandchars=\\\{\}}

\begin{document}
\pgfdeclarelayer{background}
\pgfsetlayers{background,main}
\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Contenidos}
  \tableofcontents
  % You might wish to add the option [pausesections]
\end{frame}

\section{Búsqueda Binaria discreta}

\subsection{Búsqueda binaria en un arreglo}

\begin{frame}{Buscando en listas ordenadas}
  \begin{itemize}
    \item Uno de los problemas más comunes que existen es el de querer buscar si un
          número aparece o no en una lista ordenada. \pause
    \invisible<1>{\item Es trivial ver que se puede resolver el problema en
          $O(n)$ donde $n$ es la cantidad de elementos de la lista, simplemente
          buscando uno por uno en orden.\pause
    }
    \invisible<1-2>{\item Hay una forma de aprovechar el hecho de que el arreglo
          está ordenado.
          Esta forma de buscar eficientemente se conoce como búsqueda binaria.
    }
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Ejemplo de Búsqueda Binaria}
  Supongamos que queremos buscar si el número 22 está en el siguiente arreglo:
  \begin{Verbatim}
  1 2 4 6 8 14 15 16 21 22 31 35 44 45 56 87 89 95 99 100 103 112 128
  \end{Verbatim}
  \pause
  \invisible<1>{
    Podemos preguntarnos
    ¿Es el primer elemento del arreglo el 22? No,
    ¿Es el segundo elemento del arreglo el 22?
    Tampoco... y así hasta que nos preguntamos
    ¿Es el décimo elemento del arreglo el 22? Sí!
  }
\end{frame}

\begin{frame}[fragile]{Ejemplo de Búsqueda Binaria}
  Con búsqueda binaria podemos buscar así
  \begin{Verbatim}
    \textbf{\textcolor{blue}{1}} 2 4 6 8 14 15 16 21 22 31 \textbf{\textcolor{red}{35}} 44 45 56 87 89 95 99 100 103 112 128 \textbf{\textcolor{blue}{.}}
  \end{Verbatim}
  \pause
  \begin{Verbatim}
    \textbf{\textcolor{blue}{1}} 2 4 6 8 \textbf{\textcolor{red}{14}} 15 16 21 22 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
  \end{Verbatim}
  \pause
  \begin{Verbatim}
    1 2 4 6 8 \textbf{\textcolor{blue}{14}} 15 16 \textbf{\textcolor{red}{21}} 22 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
  \end{Verbatim}
  \pause
  \begin{Verbatim}
    1 2 4 6 8 14 15 16 \textbf{\textcolor{blue}{21}} \textbf{\textcolor{red}{22}} 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
  \end{Verbatim}
  \pause
  \invisible<1-4>{
    Notemos que en 4 pasos pudimos encontrar el 22 cuando
    antes nos llevaba 10 pasos.
  }
\end{frame}

\begin{frame}[fragile]{Código de la búsqueda binaria}
\begin{lstlisting}
# A es el arreglo ordenado, v es el valor a buscar
# Si v esta en A entonces esta en el intervalo [L, R) de A
def busqueda_binaria(A, v):
    L = 0
    R = len(A)
    while R - L > 1:
        M = (L + R) / 2
        if v < M:
            R = M
        else:
            L = M
    if A[L] == v:
        return L
    return None  # Not found
\end{lstlisting}
¿Funciona? ¿Encuentra la primera aparición de $v$? ¿La última? ¿Una cualquiera?


\end{frame}

\begin{frame}[fragile]{Ejemplo de Búsqueda Binaria}
Buscar un número que no está es mucho más costoso con búsqueda lineal,
sin embargo con búsqueda binaria es igual de rápido que buscar un número que
si está. Busquemos por ejemplo el 23.
\begin{Verbatim}
\textbf{\textcolor{blue}{1}} 2 4 6 8 14 15 16 21 22 31 \textbf{\textcolor{red}{35}} 44 45 56 87 89 95 99 100 103 112 128 \textbf{\textcolor{blue}{.}}
\end{Verbatim}
\pause
\begin{Verbatim}
\textbf{\textcolor{blue}{1}} 2 4 6 8 \textbf{\textcolor{red}{14}} 15 16 21 22 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
\end{Verbatim}
\pause
\begin{Verbatim}
1 2 4 6 8 \textbf{\textcolor{blue}{14}} 15 16 \textbf{\textcolor{red}{21}} 22 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
\end{Verbatim}
\pause
\begin{Verbatim}
1 2 4 6 8 14 15 16 \textbf{\textcolor{blue}{21}} \textbf{\textcolor{red}{22}} 31 \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
\end{Verbatim}
\pause
\begin{Verbatim}
1 2 4 6 8 14 15 16 21 \textbf{\textcolor{blue}{22}} \textbf{\textcolor{red}{31}} \textbf{\textcolor{blue}{35}} 44 45 56 87 89 95 99 100 103 112 128
\end{Verbatim}
\pause
\begin{Verbatim}
1 2 4 6 8 14 15 16 21 \textbf{\textcolor{blue}{22}} \textbf{\textcolor{blue}{31}} 35 44 45 56 87 89 95 99 100 103 112 128
\end{Verbatim}
\end{frame}

\begin{frame}{Complejidad de la búsqueda binaria}
La complejidad de la búsqueda binaria es $O(\log n)$ donde $n$ es el tamaño del
arreglo. Esto es fácil de probar ya que en cada paso se reduce el espacio de
búsqueda a la mitad.
\end{frame}

\subsection{Más allá de los arreglos}

\begin{frame}{Funciones monótonas}
Cuando tenemos una función $f$ que cumple
$$x > y \Rightarrow f(x) \geq f(y)$$
decimos que $f$ es monótona creciente. Si en cambio $f$ cumple
$$x > y \Rightarrow f(x) \leq f(y)$$
decimos que $f$ es monótona decreciente.
Si $f$ es monótona creciente o monótona decreciente decimos que $f$ es monótona.

Cuando una función es monótona creciente (decreciente) podemos aplicar
búsqueda binaria para buscar el menor valor de $x$ tal que
$f(x) \geq y$ ($f(x) \leq y$) para un $y$ dado.
\end{frame}

\begin{frame}{Ejemplo de búsqueda binaria con funciones monótonas}

Pedro estudia Ciencias de la Computación y le quedan por cursar $n$ materias.
Él sabe que si hace una sóla materia le va a costar 1 unidad de esfuerzo
aprobarla, pero si hace una segunda materia le cuesta 2 unidades de esfuerzo
para aprobar la segunda materia, y en general, si hace $i$ materias le cuesta
$i$ unidades de esfuerzo aprobar la $i$-ésima materia.

El sabe que hacer un esfuerzo de $t$ unidades o más lo va a estrezar y por lo
tanto va a dejar la carrera. Cuántos cuatrimestres necesita para recibirse?

\end{frame}

\begin{frame}{Ejemplo de búsqueda binaria con funciones monótonas}

\begin{itemize}
  \item Lo primero que tenemos que hacer es calcular cuántas materias puede
        hacer por cuatrimestre. Luego es una división.\pause
  \invisible<1>{\item Para calcular cuántas materias puede hacer por
    cuatrimestre, sabemos que ese número $x$ cumple con $\frac{x(x+1)}{2} < t$.
    Luego hacemos búsqueda binaria para encontrar ese máximo valor posible de
    $x$.
  }
\end{itemize}
\end{frame}
\section{Búsqueda binaria continua}

\subsection{Búsqueda binaria para el cálculo de funciones inversas}

\begin{frame}{Búsqueda binaria continua}
\begin{itemize}
  \item Así como usamos búsqueda binaria cuando tenemos un dominio discreto,
        también podemos usar búsqueda binaria cuando el dominio es continuo. \pause
  \invisible<1>{\item Por ejemplo, tenemos una función $f$ monótona creciente y
        continua y queremos hallar el mínimo $x$ tal que $f(x) \geq y$.
  }
  \pause
  \invisible<1-2>{\item Como $f$ es continua, si el mínimo $x_0$ existe tenemos
    qué $f(x) = y$, es decir $x_0 = f^{-1}(y)$.
  }
\end{itemize}
\end{frame}

\begin{frame}{Ejemplo de búsqueda binaria para encontrar el inverso de una función}
\begin{itemize}
  \item Dado un número $x$, calcular la raiz cuadrada de $x$ \pause
  \invisible<1>{
    \item ¿Cuál sería el criterio de terminación? ¿Cuántas iteraciones necesitamos?
  }\pause
  \invisible<1-2>{
    \item A diferencia del caso de la búsqueda binaria discreta, cuando el dominio
    de la búsqueda binaria es continuo tenemos que poner un punto de corte
    arbitrario para la búsqueda binaria.
  }
  \pause
  \invisible<1-3>{
    \item Podríamos cortar por ejemplo cuándo $R - L < 10^{-9}$ que nos da una
    precisión aceptable.
  }
  \pause
  \invisible<1-4>{
    \item Cuando el ciclo termina, tanto $L$ como $R$ contienen la respuesta con
    un error de a lo sumo $10^{-9}$.
  }
  \pause
  \invisible<1-5>{\item Método de Newton}
\end{itemize}
\end{frame}

\subsection{Búsqueda binaria con funciones de imagen booleana}

\begin{frame}{Búsqueda binaria con predicados booleanos}
\begin{itemize}
  \item Ya vimos como hace búsqueda binaria sobre funciones que tienen una
  imagen numérica y que son monotonas.
  \pause
  \invisible<1>{
    \item Cuando la imagen de la función es booleana, por ejemplo, dado un\
    predicado booleano $P$, encontrar el mínimo $x$ tal que $P(x)$ es verdadero,
    también podemos definir monotonía y aplicar búsqueda binaria.
  }
  \pause
  \invisible<1-2>{
    \item Cuando un predicado es falso para todos los $x < x_0$ y verdadero para
    los $x \geq x_0$ decimos que el predicado monótono.
    Esto equivale con asignarle $0$ a falso y $1$ a verdadero, en este caso el
    predicado es monótono creciente.
  }
\end{itemize}
\end{frame}

\begin{frame}{Ejemplo de búsqueda binaria con predicados booleanos}
\begin{block}{Problema}
Fito tiene que cruzar un cuarto lleno de dinosaurios desde la esquina superior
izquierda hasta la esquina inferior derecha. Son dadas las posiciones de los
dinosaurios y las dimensiones del cuarto.
Se sabe que si pasa a distancia menor a $T$ de un dinosaurio, este lo ve y se
lo come. Cuál es el mínimo $T$ tal que Fito puede lograr su objetivo?
\end{block}
\end{frame}
\subsection{Algunos comentarios}
\begin{frame}{}
  \begin{itemize}
    \item El caso no monónoto:
    \item Búsqueda ternaria:
  \end{itemize}
\end{frame}
\end{document}
